import { useState, useEffect, useRef } from 'react'
import './App.css'
import React from 'react'

interface Server {
  id: string;
  name: string;
  hostname: string;
  services: Service[];
  notes?: string;
  notesVisible: boolean;
}

interface Service {
  id: string;
  name: string;
  port: number;
  path?: string;
}

interface ColorPalette {
  headerBackground: string;
  pageBackground: string;
  serverBackground: string;
  serviceBackground: string; // Also used for search, muted buttons
  serverText: string; // Also used for Add Service
  serviceText: string; // Also used for buttons palette
  secondaryText: string; // Used for IP & Port
  accentButton: string;
  statusRed: string;
  statusAmber: string;
  statusGreen: string;
}

// Default color palette
const defaultPalette: ColorPalette = {
  headerBackground: '#171717',
  pageBackground: '#1B1B1B',
  serverBackground: '#252525',
  serviceBackground: '#333333',
  serverText: '#e0e0e0',
  serviceText: '#DBA33A',
  secondaryText: '#a0a0a0',
  accentButton: '#CC7B18',
  statusRed: '#EC6141',
  statusAmber: '#DBA33A',
  statusGreen: '#7BB961'
};

type SortOption = 'name' | 'port';
type StorageType = 'localStorage' | 'sessionStorage' | 'indexedDB' | 'none';

// Directly use IndexedDB as primary storage
const DB_NAME = 'selfhosted_dashboard';
const DB_VERSION = 1;
const STORE_NAME = 'servers_store';
const DB_KEY = 'servers_data';
const PALETTE_KEY = 'color_palette';

// Helper function to open IndexedDB
const openDB = (): Promise<IDBDatabase> => {
  return new Promise((resolve, reject) => {
    try {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      
      request.onerror = (event) => {
        console.error("Error opening IndexedDB", event);
        reject(new Error("Could not open IndexedDB"));
      };
      
      request.onsuccess = (event) => {
        resolve((event.target as IDBOpenDBRequest).result);
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        }
      };
    } catch (error) {
      console.error("Critical error opening IndexedDB:", error);
      reject(error);
    }
  });
};

// Save data to IndexedDB
const saveToIndexedDB = async (data: Server[]): Promise<boolean> => {
  try {
    const db = await openDB();
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    
    return new Promise((resolve) => {
      const request = store.put({
        id: DB_KEY,
        data
      });
      
      request.onsuccess = () => {
        console.log("Data saved to IndexedDB successfully", data);
        resolve(true);
      };
      
      request.onerror = (event) => {
        console.error("Error saving to IndexedDB", event);
        resolve(false);
      };
      
      // Close database when transaction is complete
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error("IndexedDB save failed", error);
    return false;
  }
};

// Get data from IndexedDB
const getFromIndexedDB = async (): Promise<Server[] | null> => {
  try {
    const db = await openDB();
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    
    return new Promise((resolve) => {
      const request = store.get(DB_KEY);
      
      request.onsuccess = () => {
        if (request.result) {
          console.log("Data retrieved from IndexedDB", request.result.data);
          resolve(request.result.data);
        } else {
          console.log("No data found in IndexedDB");
          resolve(null);
        }
      };
      
      request.onerror = (event) => {
        console.error("Error reading from IndexedDB", event);
        resolve(null);
      };
      
      // Close database when transaction is complete
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error("IndexedDB get failed", error);
    return null;
  }
};

// Save color palette to IndexedDB
const savePaletteToIndexedDB = async (palette: ColorPalette): Promise<boolean> => {
  try {
    const db = await openDB();
    const transaction = db.transaction(STORE_NAME, 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    
    return new Promise((resolve) => {
      const request = store.put({
        id: PALETTE_KEY,
        data: palette
      });
      
      request.onsuccess = () => {
        console.log("Color palette saved to IndexedDB successfully", palette);
        resolve(true);
      };
      
      request.onerror = (event) => {
        console.error("Error saving palette to IndexedDB", event);
        resolve(false);
      };
      
      // Close database when transaction is complete
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error("IndexedDB palette save failed", error);
    return false;
  }
};

// Get color palette from IndexedDB
const getPaletteFromIndexedDB = async (): Promise<ColorPalette | null> => {
  try {
    const db = await openDB();
    const transaction = db.transaction(STORE_NAME, 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    
    return new Promise((resolve) => {
      const request = store.get(PALETTE_KEY);
      
      request.onsuccess = () => {
        if (request.result) {
          console.log("Color palette retrieved from IndexedDB", request.result.data);
          resolve(request.result.data);
        } else {
          console.log("No color palette found in IndexedDB");
          resolve(null);
        }
      };
      
      request.onerror = (event) => {
        console.error("Error reading palette from IndexedDB", event);
        resolve(null);
      };
      
      // Close database when transaction is complete
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error("IndexedDB palette get failed", error);
    return null;
  }
};

function App() {
  const [servers, setServers] = useState<Server[]>([]);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isEditingServer, setIsEditingServer] = useState(false);
  const [newServer, setNewServer] = useState({ name: '', hostname: '', notes: '', notesVisible: false });
  const [editingServerId, setEditingServerId] = useState<string | null>(null);
  const [isAddingService, setIsAddingService] = useState(false);
  const [currentServerId, setCurrentServerId] = useState<string | null>(null);
  const [newService, setNewService] = useState<{ name: string; port: string; path: string }>({ name: '', port: '', path: '' });
  const [sortBy, setSortBy] = useState<SortOption>('name');
  // @ts-ignore - used in fallback storage logic
  const [storageType, setStorageType] = useState<StorageType>('indexedDB');
  const [dataLoaded, setDataLoaded] = useState(false);
  // @ts-ignore - used in form focus handling
  const [activeInputId, setActiveInputId] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [notification, setNotification] = useState<{show: boolean, message: string}>({
    show: false,
    message: ''
  });
  const [colorPalette, setColorPalette] = useState<ColorPalette>(defaultPalette);
  const [isPaletteDialogOpen, setIsPaletteDialogOpen] = useState(false);
  
  // Refs for dialogs
  const serverDialogRef = useRef<HTMLDivElement>(null);
  const serviceDialogRef = useRef<HTMLDivElement>(null);
  const paletteDialogRef = useRef<HTMLDivElement>(null);

  // Filter servers based on search term
  const getFilteredServers = () => {
    if (!searchTerm.trim()) {
      return getSortedServers();
    }

    const lowerSearchTerm = searchTerm.toLowerCase();
    
    // Filter servers by name
    const filteredByServerName = servers.filter(server => 
      server.name.toLowerCase().includes(lowerSearchTerm)
    );
    
    if (filteredByServerName.length > 0) {
      return filteredByServerName;
    }
    
    // If no servers match, check for services that match
    return servers.filter(server => 
      server.services.some(service => 
        service.name.toLowerCase().includes(lowerSearchTerm)
      )
    );
  };

  // Filter services based on search term
  const getFilteredServices = (services: Service[]) => {
    if (!searchTerm.trim()) {
      return getSortedServices(services);
    }

    const lowerSearchTerm = searchTerm.toLowerCase();
    
    // Check if we're filtering by server name
    const serverMatch = servers.some(server => 
      server.name.toLowerCase().includes(lowerSearchTerm)
    );
    
    if (serverMatch) {
      // If filtering by server name, show all services
      return getSortedServices(services);
    }
    
    // Otherwise, filter services by name
    return getSortedServices(
      services.filter(service => 
        service.name.toLowerCase().includes(lowerSearchTerm)
      )
    );
  };

  // Clear search
  const clearSearch = () => {
    setSearchTerm('');
  };

  // Handle search input changes
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };

  // Handle search form submission
  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Just prevent default form submission, filtering happens as you type
  };

  // Handle form-group active state
  const handleInputFocus = (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    setActiveInputId(e.currentTarget.id);
  };

  const handleInputBlur = () => {
    setActiveInputId(null);
  };

  // Function to show notification
  const showNotification = (message: string) => {
    setNotification({
      show: true,
      message
    });
    setTimeout(() => setNotification({show: false, message: ''}), 2000);
  };

  // Load data and color palette on component mount
  useEffect(() => {
    const loadData = async () => {
      try {
        // Get servers
        const serversData = await getFromIndexedDB();
        if (serversData) {
          // Ensure all servers have notesVisible property properly set
          const updatedServers = serversData.map((server) => ({
            ...server,
            notesVisible: server.notesVisible === true // Explicitly check for true, defaults to false
          }));
          console.log('Loaded servers with updated notesVisible flags:', updatedServers);
          setServers(updatedServers);
        } else {
          try {
            // Fallback to localStorage
            const localData = localStorage.getItem('servers');
            if (localData) {
              const parsedData = JSON.parse(localData);
              // Ensure all servers have notesVisible property properly set
              const updatedServers = parsedData.map((server: any) => ({
                ...server,
                notesVisible: server.notesVisible === true // Explicitly check for true, defaults to false
              }));
              console.log('Loaded servers from localStorage with updated notesVisible flags:', updatedServers);
              setStorageType('localStorage');
              setServers(updatedServers);
              console.log("Data loaded from localStorage");
            }
          } catch (e) {
            console.error("Error loading fallback data from localStorage", e);
          }
        }
        
        // Get color palette
        const paletteData = await getPaletteFromIndexedDB();
        if (paletteData) {
          setColorPalette(paletteData);
          applyColorPalette(paletteData);
        } else {
          applyColorPalette(defaultPalette);
        }
        
        setDataLoaded(true);
      } catch (e) {
        console.error("Error during initial data load", e);
        setDataLoaded(true);
      }
    };

    loadData();
  }, []);
  
  // Save to IndexedDB whenever servers change, but only after initial data load
  useEffect(() => {
    // Don't save until the initial data is loaded
    if (!dataLoaded) {
      console.log('Data not yet loaded, skipping save');
      return;
    }
    
    console.log('Servers state changed, saving to IndexedDB:', servers);
    
    const saveData = async () => {
      try {
        const success = await saveToIndexedDB(servers);
        if (success) {
          console.log('Successfully saved data to IndexedDB');
        } else {
          console.error('Failed to save to IndexedDB');
          
          // Try fallback to localStorage
          try {
            localStorage.setItem('dashboard_servers', JSON.stringify(servers));
            console.log('Fallback save to localStorage successful');
          } catch (storageError) {
            console.error('Fallback save to localStorage failed:', storageError);
          }
        }
      } catch (error) {
        console.error('Error during save operation:', error);
      }
    };
    
    saveData();
  }, [servers, dataLoaded]);

  const handleAddServer = () => {
    if (!newServer.name || !newServer.hostname) {
      alert('Please enter both server name and hostname');
      return;
    }

    console.log('Adding new server with notesVisible defaulting to false');

    const server: Server = {
      id: Date.now().toString(),
      name: newServer.name,
      hostname: newServer.hostname,
      services: [],
      notes: newServer.notes,
      notesVisible: false // Always false by default
    };

    setServers([...servers, server]);
    setNewServer({ name: '', hostname: '', notes: '', notesVisible: false });
    setIsDialogOpen(false);
  };

  const openEditServerDialog = (serverId: string) => {
    const server = servers.find((s: Server) => s.id === serverId);
    if (server) {
      // Debug checking state
      console.log('Opening edit dialog for server:', server.id, 'notesVisible:', server.notesVisible);
      
      setNewServer({ 
        name: server.name, 
        hostname: server.hostname, 
        notes: server.notes || '', 
        notesVisible: server.notesVisible || false // Use direct value with fallback to false
      });
      setEditingServerId(serverId);
      setIsEditingServer(true);
      setIsDialogOpen(true);
    }
  };

  const handleEditServer = () => {
    if (!newServer.name || !newServer.hostname || !editingServerId) {
      alert('Please enter both server name and hostname');
      return;
    }

    // Log the actual boolean value for clarity
    const notesVisibleValue = Boolean(newServer.notesVisible);
    console.log('Saving server with notesVisible:', notesVisibleValue, '(original value:', newServer.notesVisible, ', type:', typeof newServer.notesVisible, ')');

    setServers(servers.map((server: Server) => {
      if (server.id === editingServerId) {
        const updatedServer = {
          ...server,
          name: newServer.name,
          hostname: newServer.hostname,
          notes: newServer.notes,
          notesVisible: notesVisibleValue
        };
        console.log('Updated server:', updatedServer.id, 'notesVisible set to:', updatedServer.notesVisible);
        return updatedServer;
      }
      return server;
    }));

    setNewServer({ name: '', hostname: '', notes: '', notesVisible: false });
    setIsDialogOpen(false);
    setIsEditingServer(false);
    setEditingServerId(null);
    showNotification("Server updated successfully");
  };

  const handleDeleteServer = (serverId: string) => {
    if (confirm('Are you sure you want to delete this server?')) {
      setServers(servers.filter((server: Server) => server.id !== serverId));
    }
  };

  // @ts-ignore - used for toggling notes visibility
  const toggleNotesVisibility = (serverId: string) => {
    setServers(servers.map((server: Server) => {
      if (server.id === serverId) {
        const newVisibility = !server.notesVisible;
        console.log('Toggling notes visibility for server:', server.id, 'from:', server.notesVisible, 'to:', newVisibility);
        return {
          ...server,
          notesVisible: newVisibility
        };
      }
      return server;
    }));
  };

  const handleAddService = () => {
    if (!newService.name || !newService.port || !currentServerId) {
      alert('Please enter service name and port');
      return;
    }

    const service: Service = {
      id: Date.now().toString(),
      name: newService.name,
      port: parseInt(newService.port),
      path: newService.path
    };

    setServers(servers.map((server: Server) => {
      if (server.id === currentServerId) {
        return {
          ...server,
          services: [...server.services, service]
        };
      }
      return server;
    }));

    setNewService({ name: '', port: '', path: '' });
    setIsAddingService(false);
  };

  const handleDeleteService = (serverId: string, serviceId: string) => {
    if (confirm('Are you sure you want to delete this service?')) {
      setServers(servers.map((server: Server) => {
        if (server.id === serverId) {
          return {
            ...server,
            services: server.services.filter(service => service.id !== serviceId)
          };
        }
        return server;
      }));
    }
  };

  // Apply color palette changes in real-time
  useEffect(() => {
    applyColorPalette(colorPalette);
  }, [colorPalette]);

  // Reset palette to defaults and save them
  const resetPalette = async () => {
    try {
      // Set the palette to defaults
      setColorPalette(defaultPalette);
      
      // Immediately apply the default colors
      applyColorPalette(defaultPalette);
      
      // Save the default palette to storage
      const success = await savePaletteToIndexedDB(defaultPalette);
      
      if (success) {
        setIsPaletteDialogOpen(false);
        showNotification("Default colors restored and saved");
      } else {
        alert("Failed to save default colors");
      }
    } catch (err) {
      console.error("Error resetting palette:", err);
      alert("Error resetting to defaults");
    }
  };

  // Handle cancelling the palette dialog
  const cancelPaletteDialog = async () => {
    try {
      // Try to get the saved palette from IndexedDB
      const storedPalette = await getPaletteFromIndexedDB();
      
      if (storedPalette) {
        // If there's a stored palette, use it
        setColorPalette(storedPalette);
        applyColorPalette(storedPalette);
      } else {
        // If no stored palette, use defaults
        setColorPalette(defaultPalette);
        applyColorPalette(defaultPalette);
      }
      
      // Close the dialog
      setIsPaletteDialogOpen(false);
    } catch (err) {
      console.error("Error cancelling dialog:", err);
      
      // On error, revert to defaults
      setColorPalette(defaultPalette);
      applyColorPalette(defaultPalette);
      setIsPaletteDialogOpen(false);
    }
  };

  // Function to save color palette
  const savePalette = async () => {
    try {
      // Save current palette to IndexedDB
      const success = await savePaletteToIndexedDB(colorPalette);
      
      if (success) {
        // Apply the colors and close the dialog
        applyColorPalette(colorPalette);
        setIsPaletteDialogOpen(false);
        showNotification("Color settings saved successfully");
      } else {
        alert("Failed to save color settings");
      }
    } catch (err) {
      console.error("Error saving palette:", err);
      alert("Error saving color settings");
    }
  };

  // Function to apply color palette to CSS variables
  const applyColorPalette = (palette: ColorPalette) => {
    document.documentElement.style.setProperty('--header-background', palette.headerBackground);
    document.documentElement.style.setProperty('--page-background', palette.pageBackground);
    document.documentElement.style.setProperty('--server-background', palette.serverBackground);
    document.documentElement.style.setProperty('--service-background', palette.serviceBackground);
    document.documentElement.style.setProperty('--server-text', palette.serverText);
    document.documentElement.style.setProperty('--service-text', palette.serviceText);
    document.documentElement.style.setProperty('--accent-text', palette.serviceText);
    
    // Create a lighter version of the accent text for hover states
    const lighterAccentColor = getLighterColor(palette.serviceText, 15);
    document.documentElement.style.setProperty('--accent-text-hover', lighterAccentColor);
    
    document.documentElement.style.setProperty('--secondary-text', palette.secondaryText);
    document.documentElement.style.setProperty('--accent-button', palette.accentButton);
    document.documentElement.style.setProperty('--status-red', palette.statusRed);
    document.documentElement.style.setProperty('--status-amber', palette.statusAmber);
    document.documentElement.style.setProperty('--status-green', palette.statusGreen);
  };

  // Helper function to create a lighter color for hover states
  const getLighterColor = (hexColor: string, percent: number): string => {
    // Convert hex to RGB
    const r = parseInt(hexColor.substring(1, 3), 16);
    const g = parseInt(hexColor.substring(3, 5), 16);
    const b = parseInt(hexColor.substring(5, 7), 16);
    
    // Make it lighter
    const lighter = (value: number): number => {
      return Math.min(255, value + (255 - value) * (percent / 100));
    };
    
    // Convert back to hex
    const rr = Math.round(lighter(r)).toString(16).padStart(2, '0');
    const gg = Math.round(lighter(g)).toString(16).padStart(2, '0');
    const bb = Math.round(lighter(b)).toString(16).padStart(2, '0');
    
    return `#${rr}${gg}${bb}`;
  };

  // Handle color change in palette
  const handleColorChange = (key: keyof ColorPalette, value: string) => {
    // Validate that the value is a valid hex color
    if (value.match(/^#([0-9A-F]{3}){1,2}$/i) || value === '') {
      setColorPalette(prev => ({
        ...prev,
        [key]: value || '#000000' // Fallback to black if empty
      }));
    } else if (value.length <= 7) {
      // Allow partial input while typing
      setColorPalette(prev => ({
        ...prev,
        [key]: value
      }));
    }
    // Ignore invalid inputs that don't match the pattern
  };

  // Include color palette in export data
  const exportData = () => {
    try {
      const dataToExport = {
        servers,
        colorPalette
      };
      
      const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'homni-dashboard-export.json';
      a.click();
      
      URL.revokeObjectURL(url);
      showNotification("Data exported successfully");
    } catch (e) {
      console.error("Export failed", e);
      alert("Export failed");
    }
  };

  // Import data including color palette
  const importData = (event: React.ChangeEvent<HTMLInputElement>) => {
    try {
      const file = event.target.files?.[0];
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = async (e) => {
        try {
          const content = e.target?.result as string;
          const parsedData = JSON.parse(content);
          
          if (Array.isArray(parsedData.servers)) {
            await saveToIndexedDB(parsedData.servers);
            setServers(parsedData.servers);
            
            if (parsedData.colorPalette) {
              await savePaletteToIndexedDB(parsedData.colorPalette);
              setColorPalette(parsedData.colorPalette);
              applyColorPalette(parsedData.colorPalette);
            }
            
            showNotification("Data imported successfully");
          } else if (Array.isArray(parsedData)) {
            // Legacy import (servers only)
            await saveToIndexedDB(parsedData);
            setServers(parsedData);
            showNotification("Data imported successfully");
          } else {
            throw new Error("Invalid import format");
          }
        } catch (parseError) {
          console.error("Import parsing failed", parseError);
          alert("Import failed: Invalid file format");
        }
      };
      
      reader.onerror = () => {
        alert("Error reading file");
      };
      
      reader.readAsText(file);
    } catch (e) {
      console.error("Import failed", e);
      alert("Import failed");
    }
    
    // Reset the input
    event.target.value = '';
  };

  const openServiceDialog = (serverId: string) => {
    setCurrentServerId(serverId);
    setIsAddingService(true);
  };

  const getSortedServers = () => {
    // Sort servers alphabetically by name
    return [...servers].sort((a, b) => a.name.localeCompare(b.name));
  };

  const getSortedServices = (services: Service[]) => {
    return [...services].sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      } else {
        return a.port - b.port;
      }
    });
  };

  return (
    <div className="plex-app">
      <div className="header">
        <div className="header-logo">
          <div className="app-logo"></div>
          <h1>Homni</h1>
        </div>
        
        <div className="search-container">
          <form onSubmit={handleSearchSubmit}>
            <div className="search-bar">
              <input
                type="text"
                placeholder="Search servers or services..."
                value={searchTerm}
                onChange={handleSearchChange}
                aria-label="Search servers or services"
                className="search-input"
              />
              {searchTerm && (
                <button 
                  type="button" 
                  className="search-clear-button" 
                  onClick={clearSearch}
                  aria-label="Clear search"
                >
                  Ã—
                </button>
              )}
            </div>
          </form>
        </div>

        <button 
          className="header-palette-button" 
          onClick={() => setIsPaletteDialogOpen(true)}
          title="Customize Colors (Alt+P)"
        >
          <div className="header-palette-icon"></div>
        </button>
      </div>
      
      {notification.show && (
        <div className="save-notification">
          <span>{notification.message}</span>
        </div>
      )}
      
      <div className="container">
        {(searchTerm && getFilteredServers().length === 0) && (
          <div className="search-status">
            <p>No results found for "{searchTerm}"</p>
            <button className="text-button" onClick={clearSearch}>Clear search</button>
          </div>
        )}
        
        {searchTerm && getFilteredServers().length > 0 && (
          <div className="search-status">
            <p>Showing results for "{searchTerm}"</p>
            <button className="text-button" onClick={clearSearch}>Clear search</button>
          </div>
        )}
        
        {servers.length === 0 && !searchTerm ? (
          <div className="welcome-section">
            <div className="card">
              <h2>ðŸ‘‹&nbsp;&nbsp;Welcome to Homni</h2>
              
              <p>This dashboard helps you manage and access your self-hosted services across multiple servers.</p>
              <p>Click the "Add Server" button to get started.</p>
              
              <div className="welcome-buttons">
                <button 
                  className="add-button" 
                  onClick={() => setIsDialogOpen(true)}
                  title="Add Server (Alt+A)"
                >
                  Add Server
                </button>
                <input
                  type="file"
                  id="welcome-import-file"
                  accept=".json"
                  onChange={importData}
                  style={{ display: 'none' }}
                />
                <button 
                  className="header-button" 
                  onClick={() => document.getElementById('welcome-import-file')?.click()}
                  title="Import data (Alt+I)"
                >
                  Import
                </button>
              </div>
              
              <div className="keyboard-shortcuts-info">
                <h3>Keyboard Shortcuts</h3>
                <div className="keyboard-shortcuts-grid">
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Alt</kbd> + <kbd>A</kbd>
                    </div>
                    <p className="shortcut-description">Add Server</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Alt</kbd> + <kbd>I</kbd>
                    </div>
                    <p className="shortcut-description">Import Data</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Alt</kbd> + <kbd>E</kbd>
                    </div>
                    <p className="shortcut-description">Export Data</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Alt</kbd> + <kbd>P</kbd>
                    </div>
                    <p className="shortcut-description">Customize Colors</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>/</kbd> or <kbd>Alt</kbd> + <kbd>S</kbd>
                    </div>
                    <p className="shortcut-description">Focus Search</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Esc</kbd>
                    </div>
                    <p className="shortcut-description">Clear Search / Close Dialog</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Enter</kbd>
                    </div>
                    <p className="shortcut-description">Submit Form or Navigate Forms</p>
                  </div>
                  <div className="shortcut-item">
                    <div className="shortcut-keys">
                      <kbd>Tab</kbd>
                    </div>
                    <p className="shortcut-description">Navigate Between Fields</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        ) : (
          <>
            <div className="section-header">
              <div className="section-buttons">
                <button 
                  className="add-button" 
                  onClick={() => setIsDialogOpen(true)}
                  title="Add Server (Alt+A)"
                >
                  Add Server
                </button>
                <input
                  type="file"
                  id="section-import-file"
                  accept=".json"
                  onChange={importData}
                  style={{ display: 'none' }}
                />
                <button 
                  className="header-button" 
                  onClick={() => document.getElementById('section-import-file')?.click()}
                  title="Import data (Alt+I)"
                >
                  Import
                </button>
                <button 
                  className="header-button" 
                  onClick={exportData} 
                  disabled={servers.length === 0}
                  title="Export data (Alt+E)"
                >
                  Export
                </button>
              </div>
              <div className="sorting-options">
                <span>Sort services by:</span>
                <div className="sort-buttons">
                  <button 
                    className={`sort-button ${sortBy === 'name' ? 'active' : ''}`} 
                    onClick={() => setSortBy('name')}
                    aria-pressed={sortBy === 'name'}
                  >
                    Name
                  </button>
                  <button 
                    className={`sort-button ${sortBy === 'port' ? 'active' : ''}`} 
                    onClick={() => setSortBy('port')}
                    aria-pressed={sortBy === 'port'}
                  >
                    Port
                  </button>
                </div>
              </div>
            </div>
            
            <div className="servers-grid">
              {getFilteredServers().map(server => (
                <div className="server-card" key={server.id}>
                  <div className="server-header">
                    <h2>{server.name}</h2>
                    <div className="server-actions">
                      <button 
                        className="small-button" 
                        onClick={() => openEditServerDialog(server.id)}
                        title="Edit Server"
                      >
                        Edit
                      </button>
                      <button 
                        className="small-button" 
                        onClick={() => openServiceDialog(server.id)}
                        title="Add Service"
                      >
                        Add Service
                      </button>
                    </div>
                  </div>
                  
                  <div className="server-hostname-container">
                    <p className="server-hostname">{server.hostname}</p>
                  </div>

                  {server.notes && server.notesVisible && (
                    <div className="server-notes">{server.notes}</div>
                  )}
                  
                  {server.services.length > 0 ? (
                    <div className="services-list">
                      {getSortedServices(getFilteredServices(server.services)).map(service => (
                        <div className="service-wrapper" key={service.id}>
                          <a 
                            href={`http://${server.hostname}:${service.port}${service.path || ''}`} 
                            target="_blank" 
                            rel="noopener noreferrer"
                            className="service-link"
                            title={`Open ${service.name} (Port ${service.port})`}
                          >
                            <div className="service-item">
                              <span className="service-name">{service.name}</span>
                              <span className="service-port">:{service.port}</span>
                            </div>
                          </a>
                          <button 
                            className="delete-service" 
                            onClick={() => handleDeleteService(server.id, service.id)}
                            title="Delete Service"
                            aria-label={`Delete ${service.name} service`}
                          >
                            Ã—
                          </button>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <p className="no-services">No services added yet</p>
                  )}
                </div>
              ))}
            </div>
          </>
        )}
      </div>

      {/* Server Add/Edit Dialog */}
      {isDialogOpen && (
        <div className="dialog" onClick={(e) => {
          if (e.target === e.currentTarget) {
            setIsDialogOpen(false);
            setIsEditingServer(false);
          }
        }}>
          <div className="dialog-content" ref={serverDialogRef}>
            <h2 className="dialog-title">{isEditingServer ? 'Edit Server' : 'Add Server'}</h2>
            
            <form onSubmit={(e) => {
              e.preventDefault();
              if (isEditingServer) {
                handleEditServer();
              } else {
                handleAddServer();
              }
            }}>
              <div className="form-group">
                <label htmlFor="serverName">Server Name</label>
                <input
                  type="text"
                  id="serverName"
                  value={newServer.name}
                  onChange={(e) => setNewServer({...newServer, name: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="e.g. Home Server"
                  required
                  autoFocus
                />
              </div>
              
              <div className="form-group">
                <label htmlFor="serverHostname">Hostname or IP</label>
                <input
                  type="text"
                  id="serverHostname"
                  value={newServer.hostname}
                  onChange={(e) => setNewServer({...newServer, hostname: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="e.g. 192.168.1.100 or server.local"
                  required
                />
              </div>
              
              <div className="form-group">
                <label htmlFor="serverNotes">Notes (optional)</label>
                <textarea
                  id="serverNotes"
                  value={newServer.notes || ''}
                  onChange={(e) => setNewServer({...newServer, notes: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="Add any notes about this server..."
                />
              </div>
              
              <div className="form-group checkbox-group">
                <label className="checkbox-label">
                  <input 
                    type="checkbox" 
                    checked={!!newServer.notesVisible}
                    onChange={(e) => setNewServer({...newServer, notesVisible: e.target.checked})}
                  />
                  <span>Show notes on dashboard</span>
                </label>
              </div>
              
              <div className="dialog-actions">
                {isEditingServer && (
                  <button 
                    type="button" 
                    className="btn btn-delete"
                    onClick={() => {
                      if (confirm('Are you sure you want to delete this server?')) {
                        handleDeleteServer(editingServerId!);
                        setIsDialogOpen(false);
                        setIsEditingServer(false);
                      }
                    }}
                  >
                    Delete Server
                  </button>
                )}
                <button 
                  type="button" 
                  className="btn btn-cancel"
                  onClick={() => {
                    setIsDialogOpen(false);
                    setIsEditingServer(false);
                  }}
                >
                  Cancel
                </button>
                <button type="submit" className="btn btn-primary">
                  {isEditingServer ? 'Save Changes' : 'Add Server'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
      
      {/* Service Add Dialog */}
      {isAddingService && (
        <div className="dialog" onClick={(e) => {
          if (e.target === e.currentTarget) {
            setIsAddingService(false);
          }
        }}>
          <div className="dialog-content" ref={serviceDialogRef}>
            <h2 className="dialog-title">Add Service</h2>
            
            <form onSubmit={(e) => {
              e.preventDefault();
              handleAddService();
            }}>
              <div className="form-group">
                <label htmlFor="serviceName">Service Name</label>
                <input
                  type="text"
                  id="serviceName"
                  value={newService.name}
                  onChange={(e) => setNewService({...newService, name: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="e.g. Plex"
                  required
                  autoFocus
                />
              </div>
              
              <div className="form-group">
                <label htmlFor="servicePort">Port</label>
                <input
                  type="number"
                  id="servicePort"
                  value={newService.port || ''}
                  onChange={(e) => setNewService({...newService, port: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="e.g. 32400"
                  required
                  min="1"
                  max="65535"
                />
              </div>
              
              <div className="form-group">
                <label htmlFor="servicePath">Path (optional)</label>
                <input
                  type="text"
                  id="servicePath"
                  value={newService.path || ''}
                  onChange={(e) => setNewService({...newService, path: e.target.value})}
                  onFocus={handleInputFocus}
                  onBlur={handleInputBlur}
                  placeholder="e.g. /web or /admin"
                />
              </div>
              
              <div className="dialog-actions">
                <button 
                  type="button" 
                  className="btn btn-cancel"
                  onClick={() => setIsAddingService(false)}
                >
                  Cancel
                </button>
                <button type="submit" className="btn btn-primary">
                  Add Service
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
      
      {/* Color Palette Dialog */}
      {isPaletteDialogOpen && (
        <div className="dialog" onClick={(e) => {
          if (e.target === e.currentTarget) {
            cancelPaletteDialog();
          }
        }}>
          <div className="dialog-content palette-dialog-content" ref={paletteDialogRef}>
            <h2 className="dialog-title">Customize Colors</h2>
            <p className="palette-hint">Click on any color to edit. Changes are previewed immediately.</p>
            
            <div className="color-categories">
              <div className="color-category">
                <h3>Background Colors</h3>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Header Background</span>
                  <input 
                    type="color" 
                    value={colorPalette.headerBackground} 
                    onChange={(e) => handleColorChange('headerBackground', e.target.value)}
                    title="Header Background"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.headerBackground}
                    onChange={(e) => handleColorChange('headerBackground', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Page Background</span>
                  <input 
                    type="color" 
                    value={colorPalette.pageBackground} 
                    onChange={(e) => handleColorChange('pageBackground', e.target.value)}
                    title="Page Background"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.pageBackground}
                    onChange={(e) => handleColorChange('pageBackground', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Server Card Background</span>
                  <input 
                    type="color" 
                    value={colorPalette.serverBackground} 
                    onChange={(e) => handleColorChange('serverBackground', e.target.value)}
                    title="Server Card Background"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.serverBackground}
                    onChange={(e) => handleColorChange('serverBackground', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Service Background</span>
                  <input 
                    type="color" 
                    value={colorPalette.serviceBackground} 
                    onChange={(e) => handleColorChange('serviceBackground', e.target.value)}
                    title="Service Background"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.serviceBackground}
                    onChange={(e) => handleColorChange('serviceBackground', e.target.value)}
                  />
                </div>
              </div>
              
              <div className="color-category">
                <h3>Text Colors</h3>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Primary Text</span>
                  <input 
                    type="color" 
                    value={colorPalette.serverText} 
                    onChange={(e) => handleColorChange('serverText', e.target.value)}
                    title="Primary Text"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.serverText}
                    onChange={(e) => handleColorChange('serverText', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Accent Text</span>
                  <input 
                    type="color" 
                    value={colorPalette.serviceText} 
                    onChange={(e) => handleColorChange('serviceText', e.target.value)}
                    title="Accent Text"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.serviceText}
                    onChange={(e) => handleColorChange('serviceText', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Secondary Text</span>
                  <input 
                    type="color" 
                    value={colorPalette.secondaryText} 
                    onChange={(e) => handleColorChange('secondaryText', e.target.value)}
                    title="Secondary Text"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.secondaryText}
                    onChange={(e) => handleColorChange('secondaryText', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Button Color</span>
                  <input 
                    type="color" 
                    value={colorPalette.accentButton} 
                    onChange={(e) => handleColorChange('accentButton', e.target.value)}
                    title="Button Color"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.accentButton}
                    onChange={(e) => handleColorChange('accentButton', e.target.value)}
                  />
                </div>
              </div>
              
              <div className="color-category">
                <h3>Status Colors</h3>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Status - Red</span>
                  <input 
                    type="color" 
                    value={colorPalette.statusRed} 
                    onChange={(e) => handleColorChange('statusRed', e.target.value)}
                    title="Status - Red"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.statusRed}
                    onChange={(e) => handleColorChange('statusRed', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Status - Amber</span>
                  <input 
                    type="color" 
                    value={colorPalette.statusAmber} 
                    onChange={(e) => handleColorChange('statusAmber', e.target.value)}
                    title="Status - Amber"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.statusAmber}
                    onChange={(e) => handleColorChange('statusAmber', e.target.value)}
                  />
                </div>
                
                <div className="color-picker-container">
                  <span className="color-picker-label">Status - Green</span>
                  <input 
                    type="color" 
                    value={colorPalette.statusGreen} 
                    onChange={(e) => handleColorChange('statusGreen', e.target.value)}
                    title="Status - Green"
                  />
                  <input 
                    type="text" 
                    className="color-picker-input" 
                    value={colorPalette.statusGreen}
                    onChange={(e) => handleColorChange('statusGreen', e.target.value)}
                  />
                </div>
              </div>
            </div>
            
            <div className="palette-actions">
              <button 
                className="btn btn-reset"
                onClick={resetPalette}
                title="Reset to default colors"
              >
                Reset to Default
              </button>
              
              <div className="palette-action-buttons">
                <button 
                  className="btn btn-cancel"
                  onClick={cancelPaletteDialog}
                >
                  Cancel
                </button>
                <button 
                  className="btn btn-primary"
                  onClick={savePalette}
                >
                  Save Colors
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      <div className="footer">
        <div className="footer-logo"></div>
        <span>Homni, a passion project by James Forwood. Â© {new Date().getFullYear()} All Rights Reserved.</span>
      </div>
    </div>
  );
}

export default App;
